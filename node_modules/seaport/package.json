{
  "name": "seaport",
  "description": "service registry and port assignment for clusters",
  "version": "0.8.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/seaport.git"
  },
  "main": "index.js",
  "bin": {
    "seaport": "bin/cli.js"
  },
  "keywords": [
    "port",
    "allocate",
    "hub",
    "service",
    "registry",
    "roles"
  ],
  "directories": {
    "lib": ".",
    "example": "example",
    "test": "test"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "dependencies": {
    "upnode": "~0.3.1",
    "optimist": "0.3.x",
    "semver": "1.0.x"
  },
  "devDependencies": {
    "tap": "~0.2.6",
    "request": "2.9.x"
  },
  "engines": {
    "node": ">=0.4.0"
  },
  "license": "MIT",
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "readme": "seaport\n=======\n\nservice registry and port assignment for clusters\n\n[![build status](https://secure.travis-ci.org/substack/seaport.png)](http://travis-ci.org/substack/seaport)\n\n![crane](http://substack.net/images/crane.png)\n\nexample\n=======\n\nsimple service\n--------------\n\nFirst spin up the seaport server:\n\n```\n$ seaport 9090\nseaport listening on :9090\n```\n\nthen obtain a port for a server called `'web'`:\n\nserver.js:\n\n``` js\nvar seaport = require('seaport');\nvar ports = seaport.connect('localhost', 9090, { secret : 'beep boop' });\nvar http = require('http');\n\nvar server = http.createServer(function (req, res) {\n    res.end('beep boop\\r\\n');\n});\n\nports.service('web@1.2.3', function (port, ready) {\n    server.listen(port, ready);\n});\n```\n\nnow just `get()` that `'web'` service!\n\nclient.js:\n\n``` js\nvar seaport = require('seaport');\nvar ports = seaport.connect(9090, { secret : 'beep boop' });\nvar request = require('request');\n\nports.get('web@1.2.x', function (ps) {\n    var u = 'http://' + ps[0].host + ':' + ps[0].port;\n    request(u).pipe(process.stdout);\n});\n```\n\noutput:\n\n```\n$ node server.js &\n[1] 6012\n$ node client.js\nbeep boop\n```\n\nand if you spin up `client.js` before `server.js` then it still works because\n`get()` queues the response!\n\ncommand-line usage\n==================\n\n```\nUsage:\n  \n  OPTIONS\n  \n    --secret   Use a service password for seaport connections.\n\n  seaport port OPTIONS\n\n    Create seaport server.\n\n  seaport host:port show OPTIONS\n\n    Show the port map from the server at host:port.\n\n  seaport host:port service name@version OPTIONS -- [COMMAND...]\n\n    Register a service. COMMAND will get an assigned port to use as\n    its last argument. If COMMAND exits it will be restarted.\n\n  seaport host:port query name@version OPTIONS\n\n    Query the server for services matching the name@version pattern.\n    The version may contain semver patterns to specify a range.\n    Prints out a JSON array of host:port strings.\n```\n\nmethods\n=======\n\n```\nvar seaport = require('seaport')\n```\n\nAll the parameters that take a `role` parameter can be intelligently versioned\nwith [semvers](https://github.com/isaacs/node-semver) by specifying a version in\nthe `role` parameter after an `'@'` character.\n\nvar ports = seaport.connect(...)\n--------------------------------\n\nConnect to the seaport service at `...`.\n\nports.get(role, cb)\n-------------------\n\nRequest an array of host/port objects through `cb(services)` that fulfill `role`.\n\nIf there are no such services then the callback `cb` will get queued until some\nservice fulfilling `role` gets allocated.\n\nports.service(role, meta={}, cb)\n--------------------------------\n\nCreate a service fulfilling the role of `role`.\n\nReceive a callback `cb(port, ready)` with the allocated `port` and `ready()`\nfunction to call and re-assume the `port` every time the seaport service\nconnection gets interrupted.\n\nYou can optionally supply a metadata object `meta` that will be merged into the\nresult objects available when you call `.get()` or `.query()`. If you supply\n`'host'` or `'port'` keys they will be overwritten.\n\nports.allocate(role, meta={}, cb)\n---------------------------------\n\nRequest a port to fulfil a `role`. `cb(port, ready)` fires with the result.\n\nCall `ready()` when your service is ready to start accepting connections.\n\nIf `cb.length === 1` then `ready()` will be fired automatically.\n\nYou can optionally supply a metadata object `meta` that will be merged into the\nresult objects available when you call `.get()` or `.query()`. If you supply\n`'host'` or `'port'` keys they will be overwritten.\n\nports.free(port, cb)\n--------------------\n\nGive a port back. `cb(alloc)` fires when complete. You will get back the `alloc`\nobject that you would have gotten if you'd queried the service directly.\n\nIf `port` is an object, you can free ports on other services besides the\npresently connected host by passing in a `host` field in addition to a `port`\nfield.\n\nports.assume(role, port or meta={}, cb)\n---------------------------------------\n\nDictate to the server what port you are listening on.\nThis is useful for re-establishing a route without restarting the server.\n\nYou can optionally supply a metadata object `meta` that will be merged into the\nresult objects available when you call `.get()` or `.query()`. If you use `meta`\nyou must supply `meta.port` as the port argument.\n\nOther keys used by seaport like `'host'` will be overwritten.\n\nports.query(role, cb)\n---------------------\n\nGet the services that satisfy the role `role` in `cb(services)`.\nEverything after the `'@'` in `role` will be treated as a semver. If the semver\nis invalid (but not undefined) the algorithm will resort to exact matches.\n\nServices are just objects that look like: `{ host : '1.2.3.4', port : 5678 }`.\nServices can also include metadata that you've given them.\n\nports.on(eventName, cb)\n-----------------------\n\nSubscribe to events (`'free'`, `'allocate'`, and `'assume'`) from the remote\nseaport server. `ports` will also emit local `'up'`, `'down'`, and `'reconnect'`\nevents from the upnode connection.\n\n`ports` acts like a regular EventEmitter except that data won't be sent for\nremote events until you start listening for them.\n\nNote that you won't get events while the seaport server is down so you should\nprobably listen for the `'up'` event from `ports` and then call `ports.query()`\nif you are trying to keep a local cache of registry entries.\n\nserver methods\n==============\n\nInstead of using the command-line tool to spin up a seaport server, you can use\nthese api methods:\n\nvar server = seaport.createServer()\n-----------------------------------\n\nCreate a new dnode seaport server.\n\nThe server emits `'allocate'`, `'assume'`, and `'free'` events when clients\nallocate, assume, and free ports.\n\ninstall\n=======\n\nTo get the seaport library, with [npm](http://npmjs.org) do:\n\n```\nnpm install seaport\n```\n\nTo get the seaport command, do:\n\n```\nnpm install -g seaport\n```\n\nlicense\n=======\n\nMIT\n",
  "_id": "seaport@0.8.0",
  "dist": {
    "shasum": "27de5e696484290e0bc706602a2e0c75ead894c4"
  },
  "_from": "seaport"
}
